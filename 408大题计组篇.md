# 408大题计组篇
## 要求
* 每题吃透，反复横跳
## I/O中断 16
![img](https://s1.ax1x.com/2020/10/31/BUUl59.jpg)

### 解析
* 第一问：传送一个字符，需要1位起始位+1位奇校验位+1位停止位+7位ASCII码=10位（此处这个起始位要当心）；D设备将字符送入I/O端口需要0.5ms，其持续工作，1s可以传送1000/0.5=2000个字符
* 第二问
    * 图要结合I/O中断处理方式和题中的描述来理解
        * D接到启动命令到将字符送入I/O端口，此时CPU和I/O并行工作；
        * 数据准备完毕，向CPU发送中断请求，请求到相应需要10个时钟周期，CPU处于处理中断过程中
        * CPU执行中断服务程序，直到返回，共需要执行20条指令。其中在执行到第15条指令时，D设备启动，I/O和CPU进行并行工作，但是设备启动到CPU返回之前CPU被I/O占用
        * 根据上述描述使用两种颜色的笔把CPU自行处理和被I/O占用的部分区分出来
    * 完成这一任务需要多少时钟周期
        * D设备将字符传送到I/O端口+CPU请求响应+CPU执行中断服务程序（要考虑之间类似流水线重叠的部分）
        * 0.5*50Mhz+10+15\*4=25070 25070\*1000 = 25070 000
    * 其中CPU需要花费多少时钟周期
        * （10+20*4）\*1000 = 90 000
    * 中断响应阶段CPU的操作，即中断过程中硬件完成的（中断隐指令）的操作，包括关中断，保护断点（保存PC），中断服务程序寻址
### 知识点背诵

## 页式虚拟存储、TLB、Cache 16
![img](https://s1.ax1x.com/2020/10/31/BUwqqf.jpg)
![img](https://s1.ax1x.com/2020/10/31/BUwHMt.jpg)
### 解答
* 本题虚地址通过快表/慢表转换为物理地址，物理地址通过Cache/内存取数据
* 第一问
    * 页大小为8KB，按照字节编址，占13位，即虚地址和实地址的页内地址都占13位，D=13，则虚页号A=32-13=19，物理页号C=24-13=11
    * TLB采用全相联，则其标记Tag与虚页号一一对应，B=A=19
    * 主存与Cache之间通过块进行交换，主存块大小为64B，则Cache的块内地址位数G=6
    * Cache与主存采用二路组相联映射，Cache可以分为64KB/64B=2<sup>10</sup>块，共分为2<sup>9</sup>,则F为组号，F=9，物理地址和Cache地址长度应该相同，故E=24-6-9=9
    * B中存放的虚拟页号，表明该页表项对应的哪个虚页的页表项
* 第二问
    * 组号为最块号的9位，4099 = 100 / 0 0000 0011B ，则组号为3，通过F找到对应的组号或者行号，然后通过E与标记的高位部分进行比较，H= 0 0000 0100B
* 第三问
    * Cache缺失的结果是访问主存
    * 缺页的结果是访问外存，外存访问速度相对主存慢的多
    * 所以缺页时间开销大
* 第四问
    * Cache直写回主存，修改页面可能是写回外存，时间开销大，故为了减少时间开销
### 知识点背诵
* 页式虚拟存储器
    * 以页为基本单位。虚存和主存都被划分成同样大小的页，主存的页称为实页，虚存的页称为虚页
    * 页表
        * 虚拟地址到实地址的转换工具
        * 存放于主存中的一张虚页号和实页号的对照表（实际上虚页号是隐含的，通过页表基地址+虚拟页号得到对应的位置）
        * 图解页表
        ![img](https://s1.ax1x.com/2020/10/31/BUDtKI.jpg)
            * 有效位
                * 表明是否状图内存
            * 脏位
                * 表明是否经过修改
                * 采用回写策略，若被修改过，则进行替换时写回内存
            * 引用位
                * 作为替换策略的参考依据
    * 图解地址转换过程
    ![img](https://s1.ax1x.com/2020/10/31/BUriLt.jpg)
        * 取出虚拟页号，然后页表基址寄存器取出页表首地址，找到页表项
        * 若装入位为1，取出物理页号和页内地址拼接形成物理地址
        * 若装入为为0，由操作系统进行缺页处理
    * 评价
        * 页面长度固定、简单、调入方便
        * 最后一页零头会造成浪费
        * 页不是逻辑上的实体，所以处理、保护和共享都不及段式虚拟存储器方便
* TLB、Cache与页式存储器的联动
    * Cache高速缓冲存储器，主存的子集
    * TLB快表，页表的子集，页表page置放在主存，TLB置放在Cache中，减少了地址转换时的访存次数
    * 图解
    ![img](https://s1.ax1x.com/2020/10/31/BUsVn1.jpg)
        * TLB tag
            * TLB与Page之间采用全相联或者组相联
                * 若是全相联，tag的位数等于虚拟地址中虚页号的位数
                * 若是组相联，虚页号的高位部分为tag，低位部分为组号（相当于对组数求余，低位部分为求余结果，高位部分为取整结果）
        * 过程
            * 查找物理地址
                * 通过虚页号查找TLB，若是找到对应的页表项，得到物理页号，则直接与页内地址拼接得到实际地址
                * 否则访存查找慢表page，通过页表项，得到物理页号
            * 取数据
                * 得到物理地址之后，依然有两种可能，一在Cache中，则不用访存，而不在Cache中
                * 若Cache采用二路组相连，则将实际地址分为高位标记部分和低位组号，先根据组号或行进行比较，然后将高位标记与标记位进行比较，若相同且有效位为1，则根据块内地址取出对应的字，否则查找主存。
* Cache写策略
    * 写命中是指要修改的内容在Cache中，此时考虑的是是否同步修改主存；写不命中时指要修改的内容只存在于主存中，此时考虑的是是否同步修改Cache
        * 写命中
            * 全写法（写直通法）
                * CPU对Cache写命中时，同时将数据写入Cache和主存
                * 所以当进行替换时，不需要把这一块写回主存
            * 写回法
                * CPU对Cache写命中时，只修改Cache中内容，不立即写入主存，当此块被换出时才写回主存，故要设置脏位来判断是否修改过
        * 写不命中
            * 写分配法
                * 加载主存中的块到Cache，然后更新这个块（局部性）
            * 非写分配法
                * 只写入主存，不进行调块
    * 全写法和非写分配法合用，即当写命中时，同时写Cache和主存，当写不命中时，只更新主存；写回法和写分配法合用，即写命中时只写入Cache，等待调出时对内存进行覆盖，写不命中时，加载主存中的块到Cache中，然后更新

## 计算
![img](https://s1.ax1x.com/2020/11/02/BDmrbd.jpg)
### 时钟周期
* 第一问
    * CPU时钟周期 = 1/800MHz = 1.25ns
    * 总线时钟周期 = 1/200MHz = 5ns
    * 总线带宽 = 200MHz*4B = 800MB
* 第二问
### 知识点背诵
